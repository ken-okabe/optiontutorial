## Swiftで脱アルゴリズム！iOS開発を関数型（宣言型）プログラミングへパラダイムシフトしてみる

#### KenOKABE tech blog
####[←ブログコンテンツ](http://kenokabe.github.io/contents/entries/entry0/entry.html)

####Appleが新プログラミング言語 Swift を、iOSおよびOS Xアプリ開発用に提供しました。
この記事では、新言語Swiftプログラミングが既存のObjective-Cとは抜本的に異なるコーディングスタイルが可能になった事、そしてその背景となる技術的潮流について解説したいと思います。

##新言語Swiftのスペックハイライト
[AppleDeveloperのSwift紹介ページ](https://developer.apple.com/swift/)によると、

####Modern
Swift is the result of the latest research on programming languages, combined with decades of experience building Apple platforms. Named parameters brought forward from Objective-C are expressed in a clean syntax that makes APIs in Swift even easier to read and maintain. Inferred types make code cleaner and less prone to mistakes, while modules eliminate headers and provide namespaces. Memory is managed automatically, and you don’t even need to type semi-colons.

Swift has many other features to make your code more expressive:

- Closures unified with function pointers
- Tuples and multiple return values
- Generics
- Fast and concise iteration over a range or collection
- Structs that support methods, extensions, protocols.
- Functional programming patterns, e.g.: map and filter


(和訳)
####モダン
Swiftは最新のプログラミング言語研究の成果で、Appleプラットフォームを構築してきた数十年の蓄積と統合されています。
Objective-Cから継承されるパラメータはSwiftのAPIでは、よりクリーンなシンタックスで表現されており、可読性とメンテナンス性が向上しています。
匿名型はコードをクリーンにし、ミスを減らします。またヘッダを不要にし、ネームスペースを提供します。
メモリは自動管理され、文末にセミコロンは不要です。

Swiftは、その他にも貴方のコードの記述力を高める多くの特徴があります。

- 関数ポインタと統合されたクロージャ
- タプルおよび複数戻り値
- Generic
- rangeまたはcollectionにおける高速で簡潔な反復
- 構造体でメソッド、エクステンション、プロトコルをサポート
- 関数型プログラミングパターン（マップ、フィルター等）



##ファースト・インプレッション
クリーン。JavaScript（CoffeeScript）に非常によく似ています。
簡潔な表記が可能になっており、プログラミング言語の記述力が段違いに向上しています（その理由をこの記事で説明します）。

メモリ管理の自動化は、これまでサードパーティのXamarin(Monotouch),Unity,J2ObjCを利用することで可能でしたが、ようやく公式でもサポートされたことになります。
この点も含め「モダン」なのですが、新言語Swiftのモダンな言語仕様として一番重要なのは、関数型（宣言型）プログラミングのパラダイムが全面的に採用されていることでしょう。
上記ハイライトリストは、すべて関数型プログラミングを実現するための言語仕様として必須であると言えます。

##関数型(宣言型)プログラミング
ここで、しつこく関数型(宣言型)と書いてるのは、「関数型」というのが言語仕様として現れた特徴的な表現手法である一方で、「宣言型」というのはより広義のプログラミングパラダイムで「命令型」言語と対立する概念であることを補足して明示しておきたいからです。

既存のObjective-Cというのは、基本的に関数型言語ではなく、命令型プログラミング言語です。
簡潔な宣言型プログラミングを実現するのは、極めて難しい言語仕様になっています。

C#やJavaなども基本命令形プログラミング言語ですが、昨今の「モダン」な関数型(宣言型)プログラミングパラダイムの盛り上がりによる進化圧で、関数型プログラミングの特徴を取り入れるべく言語仕様の激しい改定が繰り返されてきています(C#3.0以降、Java8)。

##宣言型プログラミングとは「脱アルゴリズム」

####そもそも命令型プログラミングとは？

>命令型プログラミング（めいれいがたプログラミング、Imperative Programming）とは、計算機科学において宣言型プログラミングの対となる概念であり、計算をプログラム状態を変化させる文の列で記述するプログラミングパラダイムの一種。自然言語の命令法がなすべき行動への指令を表現するのとよく似た方法で、命令型プログラムはコンピュータが実行すべき命令列で構成される。命令型プログラミングに従ったプログラミング言語を命令型（プログラミング）言語と呼ぶ。一般に命令型プログラミングは、手続き型プログラミングと同義として扱われる。
命令型プログラミングは、宣言型プログラミング（関数型や論理型言語など）と対照的である。Haskellなどの関数型プログラミング言語では、プログラムは文の並びではないし、命令型言語が持つような広域状態を持たない。

（Wikipedia）
（補足：Swiftは、Haskellのような「純粋」関数型言語、遅延評価言語ではないので、
*「かなり関数型、宣言型になっている」
*「状態変数を持たないコーディングがかなり可能になった」
という程度です。）

さて、機械語は命令形プログラムです。より抽象化した高級なC言語も命令形パラダイムをそのまま継承し、C++、Objective-Cもその系譜です。

命令形プログラミングでは、命令を時系列の実行順に羅列し繰り返し組み合わせる必要があります。
これが「アルゴリズム」の設計です。
アルゴリズムは命令ステップの明確なリストで、命令列は、先頭から最後尾に向かって逐次的に順序良く実行されるように記述しなければなりません（フロー）。
アルゴリズムを視覚化したグラフのことを「フローチャート」と呼びます。
フローを制御するためには、フローの状態を管理する変数が必要になります。
我々はこの一連の作業を当然のように「プログラミング」と読ぶわけですが、正確には「命令形プログラミング」です。
命令形プログラミングのアルゴリズム設計はフロー制御のための多くの状態変数の管理も含め実に煩雑な作業です。
人間とはミスをする存在であるし、当然見通しも悪くなり、メンテナンスも大変になります。
ここに「バグ」が侵入する余地が生じます。
一例をあげましょう。

###【問題】１から１０までの数字を全部足して表示するコードを書け。（命令形アプローチ）

```
var s = 0;
for(var n=1; n<=10; n++)
  {
    s = s + n;
  }
console.log(s);
//55
```
(javascript)

####命令形プログラミング脳の発想

「１から１０までの数字を全部足して表示する」という「命令の流れ(フロー)」を上手にアルゴリズム設計すれば良いと思う。

フローチャートはこうなるでしょう。
sに1から10までの数字を足しこむアルゴリズム
![](http://kenokabe.github.io/contents/entries/entry20140611/img/flowchart.png)

こういうとても簡単な問題であっても上記のフローチャートは複雑に見えます。
その理由は、

- 条件判断がある。
- 分岐がある。
- 繰り返し処理がある。
- なんだか変数が多い。

そもそも「１から１０までの数字を全部足す」という問題には、変数はありません。
しかし、コードを書くときにはフロー制御するための`n`と`s`という2つの状態変数が必要になってしまい、それぞれの状態変数はフローが1回ループする度に刻々と変化して、`s`は`n`の変化に依存関係にある、適切に条件判断、分岐させる、などなどプログラマはフローの状況を完全に把握してコントロールしながらコードを設計しているのです。
プログラマーは脳内で、まるでRPGダンジョンのようなそのフローチャートに自分自身を投入して、そのフローを辿り変数の変化をウォッチしながらシミュレーションするでしょう。
プログラムが大規模で複雑になるにつれて、フローチャート（ダンジョン）は入り組み、わけがわからなくなり迷いやすくなります。
フローの制御、変数の管理は大変になり、結果バグが発生する可能性が高くなり、デバッグも難しくなっていきます。
これが、命令型プログラミングが抱える本質的で致命的な問題点です。

これは、プログラミングでは当然で不可避で仕方がない事のように思えます。
しかし、実はそうではありません。

####機械語の系譜である命令形プログラミングを捨て、より高度に抽象化された「宣言型プログラミング」へパラダイム転換すれば良いのです。

###【問題】１から１０までの数字を全部足して表示するコードを書け。（宣言形アプローチ）

```
var numbers = _([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
var plus = function(a, b)
{
  return (a + b);
};

var result = numbers
             .reduce(plus);

console.log(result);
//55
```
(javascript + 関数型ライブラリ=undersocre/lazy.js)


```
(->> (1 2 3 4 5 6 7 8 9 10)
     (reduce +)
     (println)
)
//55
```
(Clojure)

####宣言型プログラミング脳の考え方
「１から１０までの数字を全部足して表示する」ために「プログラムの流れ(フロー)」を設計するということはしない。フローを考えたり設計することは、そのフロー制御のための余計な変数が増えるし、その都度ミス、バグの介入の余地が出てしまう。
状態変数を適時コントロールして条件判断して分岐やループさせるフローの臨機応変の処理方法ではなく、対象の性質などをたった1回バシッと宣言してそれでキッチリ終わらせてしまう。

「１から１０までの数字」というのは、フローの中のループで1つずつ加算してその都度用意するのではなく、一番最初に全部用意してしまう。
そして、その全部用意したデータ（リスト）を源流として、データ（リスト/コレクション）を順次操作していき、河口の最後でデータを出力して終了。
条件分岐やループはさせず、上流から下流まで1回こっきり流して終わる。
そのようなデータの加工の流れを静的に宣言しておく。

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
というリスト/コレクション `numbers` にたいして
「足していく」という関数である`plus`あるいは`+`を引数として与え
`.reduce(plus)`
という操作をすると、
1+2+3+4+5+6+7+8+9+10
となるので、今度はその結果の
55
というデータを
`console.log` あるいは　`(println)`
で出力する。
終わり、となります。

####「１から１０までの数字を全部足して表示する」
という問題で、

「１から１０までの数字を」
↓「全部足して」
↓「表示する」

と、問題そのものズバリ、本質的なデータの加工手順、つまり最初にデータを全部用意し、数珠つなぎで順番に加工していくとう加工手順の宣言をしていっただけで回答が得られた、という極めて簡潔で無駄のない洗練されたコードになっているのがわかると思います。
このコードには手続き型のコードにあった、条件判断、分岐、繰り返しループ、そして`ｎ`と`ｓ`の状態変数はひとつもありません。
つまり、それらは手続き型プログラミング脳では最低限絶対必要で不可避、と思われていたのに、関数型（宣言型）プログラミング脳では「そんなもんは一切不要」とすべて消滅してしまったのです。同時に、入り組んだフローチャートの脳内シミューレション、ダンジョンの中に没頭して迷子になるということも回避できます。
関数型（宣言型）プログラミングでは、最初にデータを全部用意する、適時そのデータの性質を宣言していく、数珠つなぎでデータを操作していく、というふうに、源流から河口まで一回だけ流してオシマイ、簡単に全体像を俯瞰できます。

これは、 Unix系オペレーティングシステムにおける パイプ(pipe) 、もしくは パイプライン (pipeline) や、JavaScriptで不可欠な位置を築いた JQueryのメソッドチェーン と論理的にまったく同じ構造のものです。

素のJavaScriptがそれぞれのDOM要素にたいして繰り返しループで関数を何度も呼び出していた事にたいして、
JQueryでは、$() なに（オブジェクトのリスト）のすべてをまとめて一気に、
こうして（メソッド1）
ああして（メソッド2）
そうする（メソッド3）
…のように、自然にチェーン連結して表現できるようになりました。

これがまさに関数型プログラミングスタイルの強みであり、JQueryがJavaScriptの世界で圧倒的に歓迎された理由なのです。

このJQueryにせよ、前述のundersocre,lazy.jsにせよ、これらはJavaScriptの外部ライブラリなのですが、本来は「命令型」でしか対処できない制御構造をライブラリが肩代わりし、隠蔽してしまうことによりコード表現の抽象度を上げ、結果「宣言型」というプログラムパラダイムを実現しており、簡潔に洗練されたコードの記述が可能となり、プログラマーの負担を軽減しているのです。

####宣言型プログラミングとは？
>ある出力を得るにあたってそれを作成する方法ではなく、出力の性質を記述することを「宣言型」と称する。例えば、HTMLは、ページがどう見えるかを記述するものであるため、宣言的である。HTML はタイトルやフォントやテキストや画像を指定するが、具体的にコンピュータの画面にどう出力するかは記述しない。この手法は、FORTRAN、C言語、Javaなどといった命令型プログラミング言語とは全く異なる。命令型では、プログラマは実行すべきアルゴリズムを明確に記述しなければならない。つまり、命令型プログラムでは目的を達成するためのアルゴリズムを明示的に示し、宣言型プログラムでは達成すべき目的（出力）を明示的に示して、それを実現するためのアルゴリズムはソフトウェア（言語処理系）に任せる（例えば、SQLの select 文は選択すべきデータの属性を指定し、データ選択の方法は示さない）。

(Wikipedia)
「命令型プログラムでは目的を達成するためのアルゴリズムを明示的に示し、宣言型プログラムでは達成すべき目的（出力）を明示的に示して、それを実現するためのアルゴリズムはソフトウェア（言語処理系）に任せる」
というのがポイントです。

Swiftでは外部ライブラリではなく言語仕様として関数型（宣言型）の特徴が備わっており、この点が昨今、精力的に言語仕様が関数型言語になるべく改定を繰り返しているC#,Javaと同様に「モダン」であると言えます。

Clojureの祖先のLISPはリスト処理を意味する「list processing」に由来しています。
関数型（宣言型）プログラミングが強力なのは、根本に数学のスーパーパワーをそのまま活かしやすい特性を有するからです。LISPそしてClojureが大きな影響を受けているHaskellなどは、言語設計の理論的基盤に 理論計算機科学や数理論理学のラムダ計算 という体系があります。 参考） 純 LISP (pure LISP)
プログラムのフローの設計でなく、データ（リスト）や関数の定義、操作を宣言的に列挙していくという関数型（宣言型）プログラミングのスタイルはもともとこのような理論的背景があります。
手続き型プログラミングで、多くの状態変数を伴うフローの設計というのは、所詮人間のやることなので失敗しやすいし、ミスをする、バグの温床となりますす。
しかし、関数型（宣言型）プログラミングでは、フロー・アルゴリズムの設計ではなく、データ（リスト/コレクション）加工の宣言に注力するので、 コードが簡潔になり、メンテナンスがしやすく、バグが入り込む余地が少ない、数学的厳密性がそのままコードの妥当性に繋がりやすいのです。

##Swift Playground (XCode 6.0 beta)
Appleの新言語Swiftでは、以上のような関数型（宣言型）の脱アルゴリズムのプログラミングが出来るようになりました。

![](http://kenokabe.github.io/contents/entries/entry20140611/img/swift.png)

```
println("hello World")

var a = 5

var plus1 = {
    (n: Int) -> Int in
    let x = n+1
    return x
}

[0,1,2].map(plus1)

var numbers = [1,2,3,4,5,6,7,8,9,10]

var result1 = numbers.map(plus1)
println(result1)


var plus1print = {
    (n: Int) -> Int in
    let x = n+1
    println(x)
    return x
}

var result2 = numbers.map(plus1print)

var result3 =
            numbers.reduce(0) { $0 + $1 }
println(result3)

```

　
 #### KenOKABE tech blog
 ####[←ブログコンテンツ](http://kenokabe.github.io//contents/entries/entry0/entry.html)
